package main

import (
	"encoding/json"
	_ "github.com/joho/godotenv/autoload"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

type FontType struct {
	Name    string `json:"name"`
	Weight  int    `json:"weight"`
	Style   string `json:"style"`
	URLName string `json:"url_name"`
	TTF     string `json:"ttf"`
	SVG     string `json:"svg"`
	WOFF2   string `json:"woff2"`
	WOFF    string `json:"woff"`
}

type FontManifest struct {
	Name    string     `json:"name"`
	URLName string     `json:"url_name"`
	Type    []string   `json:"type"`
	Types   []FontType `json:"types"`
	Dir     string     `json:"dir"`
}

func (fontType *FontType) ToCSS(fontFamilyName string, folder string) string {
	css := "@font-face {\n" +
		"    font-family: '" + fontFamilyName + "';\n" +
		"    font-style: " + fontType.Style + ";\n" +
		"    font-display: swap;\n" +
		"    font-weight: " + strconv.Itoa(fontType.Weight) + ";\n" +
		"    src: url(" + folder + "/" + fontType.WOFF2 + ") format('woff2'),\n" +
		"         url(" + folder + "/" + fontType.WOFF + ") format('woff'),\n" +
		"         url(" + folder + "/" + fontType.SVG + ") format('svg');\n" +
		"         url(" + folder + "/" + fontType.TTF + ") format('truetype'),\n" +
		"}\n\n"
	return css
}

func main() {
	fontPageBytes, _ := ioutil.ReadFile("static/index.html")
	fontPage := string(fontPageBytes)

	println("Scanning directories...")
	files, err := ioutil.ReadDir("fonts")
	if err != nil {
		log.Fatal(err)
	}

	fontsFolder := os.Getenv("FONTS_FOLDER")

	var fonts = make(map[string]FontManifest)

	for _, f := range files {
		folderName := f.Name()
		if _, err := os.Stat(fontsFolder + "/" + folderName + "/manifest.json"); err == nil {
			file, _ := os.ReadFile(fontsFolder + "/" + folderName + "/manifest.json")
			println(folderName)
			var manifest FontManifest
			json.Unmarshal(file, &manifest)
			fonts[manifest.URLName] = manifest

			http.HandleFunc("/"+manifest.URLName, func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "text/html")
				replacements := make(map[string]string)
				replacements["name"] = manifest.Name
				replacements["url_name"] = manifest.URLName
				returnV := fontPage
				for s, s2 := range replacements {
					returnV = strings.ReplaceAll(returnV, "{"+s+"}", s2)
				}
				w.Write([]byte(returnV))
			})

			http.HandleFunc("/api/fonts/"+manifest.URLName, func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "application/json")
				marshal, err := json.Marshal(manifest)
				if err != nil {
					log.Println("Error")
				}
				w.Write(marshal)
			})

			http.HandleFunc("/_/"+manifest.URLName, func(w http.ResponseWriter, r *http.Request) {
				w.Header().Set("Content-Type", "text/css")
				w.Header().Set("Access-Control-Allow-Origin", "*")
				w.WriteHeader(http.StatusOK)

				queryParam := strings.TrimSpace(r.URL.Query().Get("v"))
				variants := strings.Split(queryParam, ",")
				builder := strings.Builder{}
				builder.WriteString("/* Generated by fonts.intera.dev */")

				fontFamilyName := manifest.Name

				if r.URL.Query().Get("as") != "" {
					fontFamilyName = r.URL.Query().Get("as")
				}

				if queryParam == "" || len(variants) == 0 {
					for _, fontType := range manifest.Types {
						builder.WriteString(fontType.ToCSS(fontFamilyName, "https://"+r.Host+"/"+fontsFolder+"/"+folderName))
					}
				} else {
					for _, variant := range variants {
						println(variants)
						for _, fontType := range manifest.Types {
							if fontType.URLName == variant {
								builder.WriteString(fontType.ToCSS(fontFamilyName, "https://"+r.Host+"/"+fontsFolder+"/"+folderName))
							}
						}
					}
				}

				_, err := w.Write([]byte(builder.String()))
				if err != nil {
					log.Println(err)
				}
			})
		} else {
			log.Println(err)
		}
	}

	http.HandleFunc("/api/fonts", func(w http.ResponseWriter, r *http.Request) {
		w.Header().Set("Content-Type", "application/json")
		marshal, err := json.Marshal(fonts)
		if err != nil {
			log.Println("Error")
		}
		w.Write(marshal)
	})

	fs := http.FileServer(http.Dir(fontsFolder))
	http.Handle("/fonts/", http.StripPrefix("/fonts/", http.HandlerFunc(func(writer http.ResponseWriter, request *http.Request) {
		writer.Header().Set("Access-Control-Allow-Origin", "*")
		fs.ServeHTTP(writer, request)
	})))

	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		w.Write([]byte(`<style>@import url('/_/dm+serif+display'); * {font-family: 'DM Serif Display'; font-size: 28px; color: #434343; text-decoration: none; margin: 6px 20px;}</style>`))
		w.Write([]byte("<a href=\"/\" style='display: block; margin-top: 50px; margin-bottom: 10px; color: #878787;'><span style='color: #000; margin: 0px;'>Fonts</span>.intera.dev</a><br>"))
		for _, manifest := range fonts {
			w.Write([]byte("<a href=\"/" + manifest.URLName + "\">" + manifest.Name + "</a><br>"))
		}
	})

	println("Starting webserver...")
	err = http.ListenAndServe(":"+os.Getenv("HTTP_PORT"), nil)
	if err != nil {
		log.Fatal(err)
	}
}
